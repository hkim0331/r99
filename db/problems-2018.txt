;;
;; comments start by ';' character,
;; must follow blank line or it will be a problem.
;;
;; 2018-11-10, 2018-11-11

;;
;; printf と戻り値
;;

"hello, robocar!" をプリントする関数
void hello_p(void).

引数 n で与えらえれた回数分、"hello, robocar!" プリントする関数
void hellos_p(int n).

整数ひとつをキーボードから読み、
それに 1 を足した数をプリントする関数
void add1_p(void).

整数を引数にとり、それに1足した数を戻り値とする関数
int add1(int x).

円の半径（整数）をキーボードから読み、その円の面積（浮動小数点数）を
プリントする関数
void en_p(int r).

円の半径（整数）をキーボードから読み、その円の面積（浮動小数点数）を
戻り値とする関数
float en(int r).

キーボードから整数ひとつを入力し、それが偶数だったら"偶数です"、
奇数だったら"奇数です"とプリントする関数
void even_p(void).

整数 x を引数にとり、それが偶数だったら 1、
奇数だったら 0 を返す関数
int even(int x).

整数 x , y を引数にとり、それらを足した数をプリントする関数
int add2_p(int x, int y).

整数 x, y を引数にとり、それらを足した数を戻り値とする関数
int add2(int x, int y).

整数 x, y を引数にとり、それらの和、差、積、整数商をプリントする関数
void wa_sa_seki_sho_p(int x, int y).

整数 x, y を引数にとり、大きい方の整数をプリントする関数
void max_p(int x, int y).

整数 x, y を引数にとり、大きい方の整数を戻り値とする関数
int max2(int x, int y).

整数三つを引数にとり、もっとも大きい整数を戻り値とする関数
int max3(int x, int y, int z).

整数 4 つを引数にとり、もっとも大きい整数を戻り値とする関数
int max4(int x, int y, int z, int w).

;; 整数二つを引数にとり、そのうちの偶数である数をプリントする関数。
;; 偶数がなかったら "見つかりません" をプリント。
;; void evens_p(int x, int y).

;; 正の整数二つを引数にとり、偶数である数を戻り値とする関数。
;; 偶数がなかったら -1 を返せ。
;; int evens2(int x, int y).

;; 正整数三つを引数にとり、そのうちの最初の偶数を戻りとする関数。
;; 偶数なかったら -1 を返す。
;; int evens3(int x, int y, int z).

キーボードから整数 x,y を入力し、
x が y で割り切れたら "割り切る"、
そうでない時、"割り切れない" をプリントする関数
void divide_p(void).

整数二つを引数とし、第 1 引数が第 2 引数で割り切れたら 1、
そうでない時 0 を返す関数
int divide(int x, int y).

整数一つを引数とし、その約数を全てプリントする関数
void divisors_p(int n).

(*)引数の整数の全ての約数の配列を配列 ret に入れる関数
void divisors_array(int n, int ret[]).

(**)引数の整数の全ての約数の配列を戻す関数
int * divisors(int n).

100 以下の 7 の倍数を全てプリントする関数
void sevens_100_p(void).

n 以下の 7 の倍数をプリントする関数
void sevens_p(int n).

m 以上、n 以下の 7 の倍数をプリントする関数
void sevens_between_p(int m, int n).

m 以上、n 以下の k の倍数をプリントする関数
void between_p(int m, int n, int k).

整数一つを引数とし、その約数の合計を戻り値とする関数
int sum_of_divisors(int n).

整数一つを引数とし、その数が完全数かどうかを判定する関数
int is_perfect(int n).
sum_of_divisors( ) ができれば簡単。

整数一つを引数とし、
その数が素数だったら "素数です" とプリントする関数
int is_prime_p(int n).

整数一つを引数とし、
その数が素数だったら1、素数でなかったら 0 を返す関数
int is_prime(int n).

10 以下の素数は何個あるかをプリントする関数
void primes10_p(void).

100 以下の素数は何個あるかを戻り値とする関数
int primes100(void).

n 以下の素数(nは整数)は何個あるかを戻り値とする関数
int primes(int n).

;;
;; 時間で演習
;;

h 時 m 分 s 秒の h, m, s を引数にとり、0 時 0 分 0 秒からの通
算秒に変換した整数を戻り値とする関数
int time_to_int(int h, int m, int s).

時刻 h1:m1:s1 と 時刻 h2:m2:s2 の間の秒数を整数で返す関数
int sec_between(int h1, int m1, int s1, int h2, int m2, int s3).

時刻 h1:m1:s1 と 時刻 h2:m2:s2 の間の時間をプリントする関数
void times_between_p(int h1, int m1, int s1, int h2, int m2, int s3).

(*)時刻 h1:m1:s1 と 時刻 h2:m2:s2 をそれぞれ文字列として受け取り、
それらの時間差をプリントする関数
void times_between(char time1[], char time2[]).

;;
;; 西暦を平成に
;;

西暦 year を引数にとり平成で返す関数。平成にならない時は -1 を返す。
int to_heisei(int year).

西暦 year を引数にとり、閏年であれば 1、そうでなければ 0 を返す関数。
int leap(int year)

;;
;; 日数計算
;;

m1 月 d1 日から m2 月 d2 月までの日数を返す関数
int days(int m1, int d1, int m2, int m2).

y1 年 m1 月 d1 日から y2 年 m2 月 d2 月までの日数を返す関数
int days_between(int y1, int m1, int d1, int y2, int m2, int m2).

;; 二桁の整数 x について
;; ゾロ目（つまり 11 とか 22 とか）だったら
;; "ゾロ目です"
;; をプリントする関数
;; void zorome_p(int x).

;; 二桁の整数についてゾロ目となる数は何個あるかを返す関数
;; void zorome2(void).

;; from &le; x &le; to の範囲の整数 x について、
;; ゾロ目となる数は何個あるかを返す関数
;; void zorome(int from, int to).

3 桁の整数の桁を入れ替えた整数を返す関数
int rev3(int n).
例えば rev(314) の戻り値は 413 になる。310 は 13 だ。

rev3(n) が元の整数 n と等しくなる3桁の整数は何個あるかを返す関数
int how_many_rev3(void).

;; rev3(n) == n かつ is_prime(n) を満たす最大の数を返す
;; int max_rev3_and_prime(int n).

整数 n の 2 乗を戻り値とする関数
int square(int n).

整数 n の 3 乗を戻り値とする関数
int triple(int n).

整数 n の m 乗を返す関数
int power(int n, int m).

1~20 の各整数についてその2乗をプリントする関数
void squares_p(void).

整数 n のルートを超えない最大の整数を返す関数
int root(int n).
ヒントは前問。ライブラリ sqrt を使うことは反則とする。

3つの整数を引数とし、
それらの長さを各辺とする三角形がありうるかどうかを判定する関数
int triangle(int x, int y, int z).
ヒント：一番長い辺の長さ &lt; 短い辺二つの長さ

3つの整数を引数とし、
それらの長さを各辺とする直角三角形がありうるかどうかを判定する関数
int normal(int x, int y, int z).
ヒント:前問

整数 n を引数とし、それが 3 の倍数だったら1、5 の倍数だったら 2、
3 の倍数でもあり、かつ、5 の倍数でもあったら 3、
いずれでもなかったら 0 を返す関数
int fz(int n).

100 以下の整数のうち、もっとも約数の多い数を返す関数
int most_divisors100(void).
複数あるときはそのうちの一つを返せば OKとする。

n 以下の整数のうち、もっとも約数の多い数を返す関数
int most_divisors(int n).
前問に同じ。

3 桁の整数 n の各桁の総和を返す関数
int sum_of_digits3(int n).

整数 n の各桁の総和を返す関数
int sum_of_digits(int n).

整数 n から m までの総和を求める関数
int sum(int n, int m).

正の整数 n から m までの整数の積を求める関数
int product(int n, int m).

整数 n の絶対値を返す関数
int abs(int n).

整数 n が 0 だったら真、それ以外だったら偽を返す関数
int zero(int n)

彼・彼女の年齢を y とする。彼・彼女がティーンエイジャーだったら
真、そうでなければ偽を返す関数
int teenage(int y).

;;
;; float
;;

float x を四捨五入した int を返す関数
int f_to_i(float x).
ヒント: 浮動小数点数 x の整数部分は (int)x で得られる。
かっこの付け方が妙だけど、こう書く。(int)3.5 は 3 だ。4ではない。

float x を小数点第 2 位で四捨五入した float を返す関数
int f_to_f1(float x).
f_to_f1(3.14159265) の戻り値は 3.100000 になる。

float x を小数点第 n 位で四捨五入した float を返す関数
int f_to_f(float x, int n).
f_to_f(3.14159265, 4) の戻り値は 3.141600
になる。

;;
;; 乱数
;;

関数 long random(void) を呼ぶとすごく大きい整数乱数が返ってくる。
random( ) を利用し、0 以上 n 未満の正の整数乱数を返す関数
int rand(int n) を作れ。

n &le; r &lt; m の整数乱数を返す関数
int rand_between(int n, int m).

0.0 &le; r &lt; 1.0 の浮動小数点数乱数を返す関数
float randf(void).

上の randf( ) を呼び出して、2次元乱数 [x, y]
(0.0 &le; x &lt; 1.0, 0.0 &le; y &lt; 1.0)
を n 個プリントする関数
void randf_p(int n).

上の randf_p( ) を応用し、円周率 pi を求める関数
float pi(int n).
2次元乱数 [x,y]、
(0.0 &le; x &lt; 1.0, 0.0 &le; y &lt; 1.0)
を n = 1,000 個発生し、
x^2 + y^2 &le; 1 となるものを数える。多分それは 785 近辺の数になる。
とすると円周率 pi は  (785/1000)*4 と推定できる。
n を増やすと pi の精度は上がるはず。

;;
;; ファイル
;;

ファイル "/home/t/hkimura/integers.txt" には一行にひとつ、
整数が書き込まれている。
そのファイルの先頭の数字を返す関数
int head0(void).

ファイル "/home/t/hkimura/integers.txt" が何行あるかを返す関数
int lines0(void).

ファイル "/home/t/hkimura/integers.txt" の n 行目の数字を返す関数
int nth0(int n).

int nth0(int n) はもし、n がファイル
"/home/t/hkimura/integers.txt"
の最大行を超えているとプログラムが実行時エラーになる。
実行時エラーを出さずに
"最大行を超えています\n"
を表示し、戻り値 -1 を返すように改良した
int nth_improve(int).

ファイル
"/home/t/hkimura/integers.txt"
の最初の十行に含まれる整数の総和を返す関数
int sum10(void).

ファイル
"/home/t/hkimura/integers.txt"
の最初の n 行に含まれる整数の総和を返す関数
int sum_n(int n).

ファイル "/home/t/hkimura/integers.txt"
の最後の n 行に含まれる整数の総和を返す関数
int sum_tail(int n).

;;
;; 整数論
;;

n よりも大きい完全数はなにか？を求める関数
int next_perfect(int n).
next_perfect(28) はきっと 496 だ。

n 以上 m 未満の奇数の和を求める関数
int sum_odds(int n, int m).
sum_odds(100, 200) は 7500 を返す。

n 未満の素数の和を求める関数
int sum_primes_under(int n).
sum_primes_under(1000) は 76127 のはず。

n 以上 m 未満の素数の和を求める関数
int sum_primes_between(int n, int m).

関数 int factorial(int n) を定義せよ。
factorial(5) は 5! の値を戻り値とする。
0! は 1 だよ。
一般に factoria(n) = n * factorial(n-1).

factorial(0), factorial(1), factorial(2)... と次々に計算していき、
factorial(n) < 0 となる最初の n を求める関数
int factorial_overflow(void).
C 言語ではこういうことが起こる。int が有限だからね。

関数 int fibo(int n) を定義せよ。
fibo(0)=0, fibo(1)=1, fibo(2)=2 で、
一般にfibo(n) = fibo(n-1) + fibo(n-2).

fibo(n) が最初に 1,000 を超える n はいくらかを求める関数
int fibo_over1000(void).
答えはきっと 17 だ。

fibo(n) が最初に m を超える n を返す関数
int fibo_over(int m).

n 以上 m 未満となるフィボナッチ数の総和を返す関数
int sum_of_fibo_between(int n, int m).

;;
;; 文字列
;;

文字列 s が空文字列("")かどうかを判定する関数
int str_empty(char s[ ]).

文字列 s の長さを返す関数
int str_len(char s[ ]).

文字列 s に含まれる文字 c の数を返す関数
int count_chars(char s[ ], char c).

文字列 s1 と文字列 s2 が等しいかどうかを判定する関数
int str_eql(char s1[ ], char s2[ ]).

二つの文字列 s1, s2 の先頭の n 文字が等しいかどうかを判定する関数
int str_eql_n(char s1[ ], char s2[ ], int n).

文字列 s1 を文字列 s2 にコピーする関数
void str_copy(char s1[ ], char s2[ ]).
s2 は s1 をコピーするに十分な長さがあると仮定してよい。
以下同様。

文字列 s1 の後ろに文字列 s2 を連結する関数
void str_append(char s1[ ], char s2[ ]).
str_append("abc", "def") を呼び出したあと、s1 は "abcdef" となる。

文字列 s1 の n 文字目からの m 文字を s2 の先頭にコピーする関数
void str_take(char s1[ ], int n, int m, char s2[ ]).
str_take("0123456", 1, 3, s2) の呼び出しのあと、s2 は "234" となる。

文字列 s1 中に文字列 s2 が出現するかどうかを判定する関数
int str_search(char s1[ ], char s2[ ]).
s2 が s1 の何文字目から出現しているかを返そう。見つからなかった時は -1 を返せ。

文字列 s1 の n 文字目からの m 文字を削除する
void str_remove(char s1[ ], int n, int m).

文字列 s1 中に文字列 s2 が見つかる場合、s1 から s2 を削除する
void str_remove_str(char s1[ ], char s2[ ]).
見つからない時？なにも削除しないよ。

文字列 s1 の n 文字目に文字列 s2 を挿入する
void str_insert(char s1[ ], int n, char s2[ ]).

文字列 s1 中に現れる文字列 s2 を文字列 s3 で置き換える
void str_subst(char s1[ ], char s2[ ], char s3[ ]).

文字列 s1 を全て大文字にして文字列 s2 にコピーする関数
toUpper(char s1[ ], char s2[ ]).

文字列 s1 を整数に変換して返す関数
int str_to_int(char s1[ ]).
str_to_int("314")の戻り値は 214 になる。

整数 n を文字列 s[ ] に変換する関数
void int_to_str(int n, char s[ ]).
int_to_str(1023, s) の呼び出しによって 文字列 "1023" が s にコピーされる。

文字列 s1[ ] を逆にした文字列 s2[ ] を作る関数
void str_reverse(char s1[ ], char s2[ ]).

;;
;; 並べ替え
;;

サイズ n の整数配列 a[ ] に 0 ~ 99 の乱数をセットする関数
void init_randoms_99(int a[ ] , int n).

上で作った乱数配列 a[ ] を要素の大きさ順に並べ替え、b[ ] にセットする関数
sort(int a[,], int n, int b[ ]).

上で並べ替えた配列 b[ ] がまじで要素順になっているかを確認する関数
int is_sorted(int b[ ], int n).

;; 数値積分


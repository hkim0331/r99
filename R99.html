<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang='ja'>
  <head>
    <meta charset='utf-8' />
    <meta http-equiv='X-UA-Compatible' content='IE=edge' />
    <meta name='viewport' content='width=device-width, initial-scale=1.0' />
    <link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css' integrity='sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm' crossorigin='anonymous' />
    <title>R99
    </title>
    <link type='text/css' rel='stylesheet' href='/r99.css' />
  </head>
  <body>
    <div class='navbar navbar-default navbar-fixed-top'>
      <div class='container'>
        <h1 class='pahe-header hidden-xs'>R99
        </h1>
<p>
  <a href='http://robocar.melt.kyutech.ac.jp'>robocar
  </a> | 
  <a href='/problems'>problems
  </a> | 
  <a href='/users'>answers
  </a> | 
  <a href='/status'>status
  </a> | 
  <a href='/login'>login
  </a> / 
  <a href='/logout'>logout
  </a>
</p>
      </div>
    </div>
    <div class='container'>
      <p>myid: 8000
      </p>
      <pre>#include &lt;stdio.h>
#include &lt;stdlib.h></pre>
<pre>//2</pre>
<pre>void add_p(void) {
    int n;
    scanf("%i", &n);
    printf("%i + 1 becomes %i\n", n, n+1);
}</pre>
<pre>//3</pre>
<pre>void add1_p(int x) {
  printf(&quot;%i +1 becomes %i\n&quot;,x,x+1);
}</pre>
<pre>//4</pre>
<pre>int add1(int x) {
   return x+1;
}</pre>
<pre>//5</pre>
<pre>int add2(int x, int y) {
  return x+y;
}</pre>
<pre>//6</pre>
<pre>void wa_sa_seki_sho_p(int x, int y) {
  printf("x=%i,y=%i\n", x, y);
  printf("x+y=%i, x-y= %i, x*y= %i, x/y = %i\n", x+y, x-y, x*y, x/y);
}</pre>
<pre>//7</pre>
<pre>void max_p(int x, int y) {
    printf("max of %i and %i is %i\n", x, y, max2(x,y));
}</pre>
<pre>//8</pre>
<pre>int max2(int x, int y) {
  if (x>y) {
    return x;
  } else {
    return y;
  }
}</pre>
<pre>//9</pre>
<pre>int max3(int x, int y, int z) {
  return max2(max2(x, y), z);
}</pre>
<pre>//10</pre>
<pre>int max4(int x, int y, int z, int w) {
  return max2(max2(x, y), max2(z, w));
}
</pre>
<pre>//11</pre>
<pre>void even_p(void) {
  int x;

  scanf(&quot;%i&quot;, &x);
  if (x%2==0) {
    printf(&quot;偶数です。\n&quot;);
  } else {
    printf(&quot;奇数です。\n&quot;);
  }
}</pre>
<pre>//12</pre>
<pre>void even1_p(int x) {
  if (x%2==0) {
    printf("偶数です。\n");
  } else {
    printf("奇数です。\n");
  }
}</pre>
<pre>//13</pre>
<pre>int even(int x) {
  return x%2==0;
}</pre>
<pre>//14</pre>
<pre>void evens_p(int x, int y) {
  if (even(x)) {
    printf("%i\n", x);
  } else if (even(y)) {
    printf("%i\n", y);;
  } else {
    printf("見つかりません。\n");
  }
}
</pre>
<pre>//15</pre>
<pre>int evens2(int x, int y) {
  if (even(x)) {
    return x;
  } else if (even(y)) {
    return y;
  } else {
    return -1;
  }
}</pre>
<pre>//16</pre>
<pre>int evens3(int x, int y, int z) {
  if (even(x)) {
    return x;
  } else if (even(y)) {
    return y;
  } else if (even(z)) {
    return z;
  } else {
    return -1;
  }
}</pre>
<pre>//17</pre>
<pre>void divide_p(void) {
  int x;
  int y;

  scanf("%i", &x);
  scanf("%i", &y);
  if (x%y==0) {
    printf("%i は %i で割り切れる。\n", x, y);
  } else {
    printf("%i は %i で割り切れない。\n", x, y);
  }
}</pre>
<pre>//18</pre>
<pre>int divide(int x, int y) {
  return x%y==0;
}</pre>
<pre>//19</pre>
<pre>void divisors_p(int n) {
  int i;

  for (i=1; i&lt;=n; i++) {
    if (divide(n,i)) {
      printf(&quot;%i &quot;,i);
    }
  }
  printf(&quot;\n&quot;);
}
</pre>
<pre>//20</pre>
<pre>/*
n の約数には 1 と n 自身も含まれるのであった。
修正。hkimura, 1/16
*/
int sum_of_divisors(int n) {
  int i;
  int sum = 0;

  for (i=1; i&lt;=n; i++) {
    if (divide(n,i)) {
      sum += i;
    }
  }
  return sum;
}
</pre>
<pre>//21</pre>
<pre>int is_perfect(int n) {
  return n == sum_of_divisors(n) - n;
}
</pre>
<pre>//22</pre>
<pre>void is_prime_p(int n) {
  if (is_prime(n)) {
    printf("%i は素数です。\n",n);
  }
}
</pre>
<pre>//23</pre>
<pre>int is_prime(int n) {
  // return n!=1 && sum_of_divisors(n)==1;
  //
  // 上は手抜き。短いが、実行速度は遅い。
  // 手抜きしないプログラムをチラ見させよう。
  // この新しい is_prime() は速いよ。
  // 次の log int i、long int nn の理由がわかり、
  // この関数を理解できる受講生は
  // 情報応用の成績 A はかたいでしょう。

  long int i;
  long int nn = n;

  if (n==0 || n==1) {
    return 0;
  } else if (n==2) {
    return 1;
  }
  if (n%2 == 0) {
    return 0;
  }
  for (i=3; i*i&lt;=nn; i+=2) {
    if (n%i == 0) {
      return 0;
    }
  }
  return 1;
}</pre>
<pre>//24</pre>
<pre>void primes_p(void) {
  int i;
  int count = 0;

  for (i=1;i&lt;=10;i++) {
    if (is_prime(i)) {
      count+=1;
    }
  }
  printf("10以下の素数は %i 個あります。\n", count);
}
</pre>
<pre>//25</pre>
<pre>int prime100(void) {
  int i;
  int count = 0;

  for (i=1;i&lt;=100;i++) {
    if (is_prime(i)) {
      count+=1;
    }
  }
  return count;
}
</pre>
<pre>//26</pre>
<pre>int prime(int n) {
  int i;
  int count = 0;

  for (i=1;i&lt;=n;i++) {
    if (is_prime(i)) {
      count+=1;
    }
  }
  return count;
}</pre>
<pre>//27</pre>
<pre>void zorome_p(int x) {
  if (x/10 == x%10) {
    printf("%i はゾロ目です\n", x);
  }
}</pre>
<pre>//28</pre>
<pre>int zorome2(void) {
  int i;
  int count = 0;
  for (i=10;i&lt;100;i++) {
    if (i/10==i%10) {
      count += 1;
    }
  }
  return count;
}</pre>
<pre>//29</pre>
<pre>int zoro(int n) {
  int d = n%10;
  for (n /= 10; n>0; n /= 10) {
    if (n%10 != d) {
      return 0;
    }
  }
  return 1;
}

int zorome(int from, int to) {
  int i;
  int count = 0;
  for (i=from; i&lt;=to; i++) {
    if (zoro(i)) {
      count += 1;
    }
  }
  return count;
}
</pre>
<pre>//30</pre>
<pre>int rev3(int n) {
  int h = n/100;
  int t = (n%100)/10;
  int d = n%10;
  return d*100+t*10+h;
}
</pre>
<pre>//31</pre>
<pre>int how_many_rev3(void) {
  int i;
  int count = 0;

  for (i=100;i&lt;1000;i++) {
    if (rev3(i)==i) {
      count += 1;
    }
  }
  return count;
}</pre>
<pre>//32</pre>
<pre>int max_rev3_and_prime(void) {
  int i;
  int n;

  for (i=100;i&lt;1000;i++) {
    if (rev3(i)==i && is_prime(i)) {
      n = i;
    }
  }
  return n;
}</pre>
<pre>//33</pre>
<pre>void sevens_100_p(void) {
  int i;

  for (i=0; i&lt;=100; i += 7) {
    printf("%i\n",i);
  }
}
</pre>
<pre>//34</pre>
<pre>void sevens_p(int n) {
  int i;

  for (i=0; i&lt;=n; i += 7) {
    printf("%i\n",i);
  }

}
</pre>
<pre>//35</pre>
<pre>void sevens_between_p(int m, int n) {
  int i;

  for (i=m; i&lt;i+7; i++) {
    if (i%7==0) {
      break;
    }
  }
  for ( ; i&lt;=n; i += 7) {
    printf("%i\n",i);
  }
}
</pre>
<pre>//36</pre>
<pre>void between_p(int m, int n, int k) {
  int i;

  for (i=m; i&lt;i+k; i++) {
    if (i%k==0) {
      break;
    }
  }
  for ( ; i&lt;=n; i += k) {
    printf("%i\n",i);
  }
}
</pre>
<pre>//37</pre>
<pre>int square(int n) {
  return n*n;
}
</pre>
<pre>//38</pre>
<pre>int triple(int n) {
  return n*n*n;
}
</pre>
<pre>//39</pre>
<pre>// 2^31 以上は計算できない。
int power(int n, int m) {
  int ret=1;

  while (m>0) {
    ret *= n;
    m--;
  }
  return ret;
}</pre>
<pre>//40</pre>
<pre>void squares_p(void) {
  int i;

  for (i=1;i&lt;=20;i++) {
    printf("%i の2乗は %i\n", i, square(i));
  }
}
</pre>
<pre>//41</pre>
<pre>int root(int n) {
  int i;

  for (i=0;square(i)&lt;n;i++) {
    ;
  }
  return i-1;
}
</pre>
<pre>//42</pre>
<pre>int triangle(int x, int y, int z) {
  return x+y>z && y+z>x && z+x >y;
}
</pre>
<pre>//43</pre>
<pre>int normal(int x, int y, int z) {
  return square(x) + square(y) == square(z) ||
         square(y) + square(z) == square(x) ||
         square(z) + square(x) == square(y);
}
</pre>
<pre>//44</pre>
<pre>int fz(int n) {
  int ret=0;
  
  if (n%3==0) {
    ret += 1;
  }
  if (n%5==0) {
    ret += 2;
  }
  return ret;
}</pre>
<pre>//45</pre>
<pre>int number_of_divisors(int n) {
  int i;
  int num = 0;

  for (i=1; i&lt;n; i++) {
    if (divide(n,i)) {
      num +=1;
    }
  }
  return num;
}

int most_divisors10(void) {
  int i;
  int max = 0;

  for (i=1; i&lt;=10; i++) {
    if (number_of_divisors(i)> max) {
      max = i;
    }
  }
  return max;
}
</pre>
<pre>//46</pre>
<pre>int most_divisors(int n) {
  int i;
  int max_at;
  int max = 0;
  int nod;

  for (i=1; i&lt;=n; i++) {
    nod = number_of_divisors(i);
    if (nod > max) {
      max = nod;
      max_at = i;
    }
  }
  return max_at;
}</pre>
<pre>//47</pre>
<pre>int sum_of_digits3(int n) {
  int d = n % 10;
  int t = (n/10)%10;
  int h = (n/100);
  return d+t+h;
}
</pre>
<pre>//48</pre>
<pre>int sum_of_digits(int n) {
  int s;

  for (s=0; n>0; n /= 10) {
    s += n%10;
  }
  return s;
}
</pre>
<pre>//49</pre>
<pre>int sum(int n, int m) {
  int i;
  int s=0;

  for (i=n;i&lt;=m;i++) {
    s+=i;
  }
  return s;
}</pre>
<pre>//50</pre>
<pre>int product(int n, int m) {
  int i;
  int p=1;

  for (i=n;i&lt;=m;i++) {
    p *= i;
    if (p&lt;0) {
        printf(&quot;オーバーフローしました。\n&quot;);
    }
  }
  return p;
}</pre>
<pre>//51</pre>
<pre>int abs(int n) {
  if (n&lt;0) {
    return -n;
  } else {
    return n;
  }
}</pre>
<pre>//52</pre>
<pre>int zero(int n) {
  return n==0;
}
</pre>
<pre>//53</pre>
<pre>int teenage(int y) {
  return 13&lt;=y && y&lt;20;
}
</pre>
<pre>//54</pre>
<pre>int f_to_i(float x) {
  int xx = x * 10;

  if (xx%10 &lt; 5) {
    return xx/10;
  } else {
    return xx/10+1;
  }
}</pre>
<pre>//55</pre>
<pre>float f_to_f1(float x) {
  return 1.0*f_to_i(x*10)/10;
}
</pre>
<pre>//56</pre>
<pre>float f_to_f(float x, int n) {
  int pow = power(10,n);
  return 1.0*f_to_i(x*pow)/pow;
}</pre>
<pre>//57</pre>
<pre>void rand10_p(void) {
  int i;

  for (i=0;i&lt;10;i++) {
    printf("%i ", random()%10);
  }
  printf("\n");
}</pre>
<pre>//58</pre>
<pre>int rand_n(int n) {
  return random()%n;
}</pre>
<pre>//59</pre>
<pre>int rand10(void) {
  return random()%20-10;
}
</pre>
<pre>//60</pre>
<pre>int rand_between(int n, int m) {
  return n + random()%(m-n);
}
</pre>
<pre>//61</pre>
<pre>float randf(void) {
  return 1.0*(random()%100000)/100000;
}
</pre>
<pre>//62</pre>
<pre>void randf_p(int n) {
  int i;

  for (i=0; i&lt;n; i++) {
    printf("[%f, %f]\n", randf(),randf());
  }
}
</pre>
<pre>//63</pre>
<pre>float pi(int n) {
  int i;
  int count = 0;
  float x;
  float y;

  for (i=0; i&lt;n; i++) {
    x = randf();
    y = randf();
    if (x*x +y*y &lt;= 1.0) {
      count ++;
    }
  }
  return (4.0*count)/n;
}</pre>
<pre>//64</pre>
<pre>int head0(void) {
  FILE* fp;
  int n;

  fp = fopen("/home/t/hkimura/integers.txt","r");
  fscanf(fp,"%i",&n);
  fclose(fp);
  return n;
}</pre>
<pre>//65</pre>
<pre>int lines0(void) {
  FILE* fp;
  int n;
  int i;

  fp = fopen("/home/t/hkimura/integers.txt","r");
  for (i=0; ; i++) {
    if (fscanf(fp,"%i",&n)==EOF) {
      fclose(fp);
      break;
    }
  }
  return i;
}</pre>
<pre>//66</pre>
<pre>int nth0(int n) {
  FILE* fp;
  int i;
  int num;

  fp = fopen("/home/t/hkimura/integers.txt","r");
  for (i=1; ; i++) {
    if (fscanf(fp,"%i",&num)==EOF) {
      fclose(fp);
      break;
    }
    if (i==n) {
      fclose(fp);
      return num;
    }
  }
  printf("見つかりませんでした。\n");
  return -1;
}</pre>
<pre>//67</pre>
<pre>int nth1(int n) {
  int max = lines0();

  if (n > max) {
    printf("最大行を超えています。\n");
    return -1;
  } else {
    nth0(n);
  }
}</pre>
<pre>//68</pre>
<pre>int sum10(void) {
  FILE* fp;
  int i;
  int num;
  int sum=0;

  fp = fopen("/home/t/hkimura/integers.txt","r");
  for (i=0; i&lt;10 ; i++) {
    if (fscanf(fp,"%i",&num)!=EOF) {
      sum += num;
    } else {
      fclose(fp);
      printf("10個のデータを読めませんでした。\n");
      return -1;
    }
  }
  fclose(fp);
  return sum;
}</pre>
<pre>//69</pre>
<pre>int sum_n(int n) {
  FILE* fp;
  int i;
  int num;
  int sum=0;

  fp = fopen("/home/t/hkimura/integers.txt","r");
  for (i=0; i&lt;n ; i++) {
    if (fscanf(fp,"%i",&num)!=EOF) {
      sum += num;
    } else {
      fclose(fp);
      printf("%i個めのデータを読めませんでした。\n",i);
      return -1;
    }
  }
  fclose(fp);
  return sum;
}</pre>
<pre>//70</pre>
<pre>// 7529 さんに触発されて書き直し。
int sum_tail(int n) {
  FILE* fp;
  int nums[n];
  int sum = 0;
  int i;

  fp = fopen(&quot;/home/t/hkimura/integers.txt&quot;, &quot;r&quot;);
  for (i=0; ;i++) {
    if (fscanf(fp, &quot;%i&quot;, &nums[i%n])==EOF) {
      break;
    }
  }
  fclose(fp);
  for (i=0; i&lt;n; i++) {
    sum += nums[i];
  }
  return sum;
}
</pre>
<pre>//71</pre>
<pre>int next_perfect(int n) {
  int i;

  for (i=n+1; ; i++) {
    if (is_perfect(i)) {
      return i;
    }
  }
}
</pre>
<pre>//72</pre>
<pre>int sum_odds(int n, int m) {
  int i=n;
  int sum=0;

  if (i%2==0) {
    i++;
  }
  for ( ; i&lt;m; i+=2) {
    sum += i;
  }
  return sum;
}</pre>
<pre>//73</pre>
<pre>int sum_primes_under(int n) {
  int i;
  int sum=2;
  for (i=3; i&lt;n; i+=2) {
    if (is_prime(i)) {
      sum+=i;
    }
  }
  return sum;
}
</pre>
<pre>//74</pre>
<pre>int sum_primes_beween(int n, int m) {
  return sum_primes_under(n) - sum_primes_under(m);
}
</pre>
<pre>//75</pre>
<pre>int factorial(int n) {
  int i;
  int ret=1;

  for (i=1; i&lt;=n; i++) {
    ret *= i;
  }
  return ret;
}
</pre>
<pre>//76</pre>
<pre>int factorial_overflow(void) {
  int i;

  for (i=0;;i++) {
    if (factorial(i)&lt;0) {
      break;
    }
  }
  return i;
}
// でも n=13 くらいですでに変な値になる。</pre>
<pre>//77</pre>
<pre>// 再帰関数すまんが、再帰で書くのが最も自然だ。
// このフィボナッチは速いよ。
int fibo_aux(int p0, int p1, int n) {
  if (n==0) {
    return p0;
  } else {
    return fibo_aux(p1, p0+p1, n-1);
  }
}

int fibo(int n) {
  return fibo_aux(0,1,n);
}

// こういう fibo_m を考えて見ました。
// 速いよ。
#define MAX 1000
int m[MAX];

void fibo_init(void) {
  int i;
  for (i=0; i&lt;MAX; i++) {
    m[i]=-1;
  }
  m[0]=0;
  m[1]=1;
}

int fibo_m(int n) {
  if (m[n]==-1) {
    int f = fibo(n-1) + fibo(n-2);
    m[n] = f;
    return f;
  } else {
    return m[n];
  }
}

</pre>
<pre>//78</pre>
<pre>int fibo_over1000(void) {
  int i;

  for (i=0; ;i++) {
    if (fibo(i)>1000) {
      return i;
    }
  }
}</pre>
<pre>//79</pre>
<pre>int fibo_over(int m){
  int i;

  for (i=0; ;i++) {
    if (fibo(i)>m) {
      return i;
    }
  }
}
</pre>
<pre>//80</pre>
<pre>int sum_of_fibo_between(int n, int m) {
  int from = fibo_over(n);
  int to = fibo_over(m);
  int i;
  int sum=0;

  for (i=from; i&lt;to; i++) {
    sum += fibo(i);
  }
  return sum;
}
</pre>
<pre>//81</pre>
<pre>int str_len(char s[]) {
	int i;

	for (i=0; s[i]!=&apos;\0&apos;;i++) {
		;
	}
	return i;
}
</pre>
<pre>//82</pre>
<pre>int count_chars(char s[], char c) {
  int i;
  int n=0;

  for (i=0; s[i]!=&apos;\0&apos;; i++) {
    if (s[i]==c) {
      n++;
    }
  }
  return n;
}
</pre>
<pre>//83</pre>
<pre>int str_eql(char s1[], char s2[]) {
  int i;

  for (i=0; s1[i]!=&apos;\0&apos;; i++) {
   if (s1[i] != s2[i]) {
      return 0;
    }
  }
  return s1[i]==s2[i];
}</pre>
<pre>//84</pre>
<pre>int str_eql_n(char s1[], char s2[], int n) {
  int i;

  for (i=0; i&lt;n; i++) {
    if (s1[i] != s2[i]) {
      return 0;
    }
  }
  return 1;
}
</pre>
<pre>//85</pre>
<pre>void str_copy(char s1[], char s2[]) {
  int i;

  for (i=0; s1[i]!=&apos;\0&apos;; i++) {
    s2[i]=s1[i];
  }
  s2[i]=&apos;\0&apos;;
}
</pre>
<pre>//86</pre>
<pre>void str_append(char s1[], char s2[]) {
  int i = str_len(s1);
  int j;

  for (j=0; s2[j]!=&apos;\0&apos;; j++) {
    s1[i] = s2[j];
    i++;
  }
  s1[i]=&apos;\0&apos;;
}</pre>
<pre>//87</pre>
<pre>void str_take(char s1[], int n, int m, char s2[]) {
  int i,j;

  j=0;
  for (i=n;i&lt;n+m;i++) {
    s2[j]=s1[i];
    j++;
  }
  s2[j]=&apos;\0&apos;;
}
</pre>
<pre>//88</pre>
<pre>int str_search(char s1[], char s2[]) {
  int len1= str_len(s1);
  int len2= str_len(s2);
  char s3[len2 + 1]; // 1 for &apos;\0&apos;
  int i;

  for (i=0; i&lt;len1-len2; i++) {
    str_take(s1,i,len2,s3);
    if (str_eql(s2,s3)) {
      return i;
    }
  }
  return -1;
}
</pre>
<pre>//89</pre>
<pre>void str_remove(char s1[], int n, int m) {
  int i;

  if (n> str_len(s1) || n+m > str_len(s1)) {
    printf(&quot;文字列 %s の長さを超えています。\n&quot;, s1);
  } else {
    for (i=n; s1[i]!=&apos;\0&apos;;i++) {
      s1[i] = s1[i+m];
    }
    s1[i]=&apos;\0&apos;;
  }
}
</pre>
<pre>//90</pre>
<pre>void str_remove_str(char s1[], char s2[]) {
  int i;

  i = str_search(s1, s2);
  if (i>0) {
    str_remove(s1, i, str_len(s2));
  }
}
</pre>
<pre>//91</pre>
<pre>void str_insert(char s1[], int n, char s2[]) {
  int len1 = str_len(s1);
  char s3[len1+1]; // 1 for &apos;\0&apos;

  str_take(s1,n,len1-n, s3);
  s1[n] = &apos;\0&apos;;
  str_append(s1,s2);
  str_append(s1,s3);
}</pre>
<pre>//92</pre>
<pre>void str_subst(char s1[], char s2[], char s3[]) {
  int found = str_search(s1,s2);
  int len = str_len(s2);

  if (found != -1) {
    str_remove(s1, found, len);
    str_insert(s1, found, s3);
  }
}
</pre>
<pre>//93</pre>
<pre>void toUpper(char s1[], char s2[]) {
  int d = &apos;A&apos;-&apos;a&apos;;
  int i;

  for (i=0; s1[i]!=&apos;\0&apos;; i++) {
    if (&apos;a&apos;&lt;= s1[i] && s1[i]&lt;=&apos;z&apos;) {
      s2[i] = s1[i]+d;
    } else {
      s2[i] = s1[i];
    }
  }
  s2[i]=&apos;\0&apos;; // I forgot.
}</pre>
<pre>//94</pre>
<pre>int str_to_int(char s1[]) {
  int i;
  int n = 0;

  for (i=0; s1[i]!=&apos;\0&apos;; i++) {
    n = (n*10 + s1[i]-&apos;0&apos;);
  }
  return n;
}
</pre>
<pre>//95</pre>
<pre>void str_reverse(char s1[], char s2[]) {
  int i = str_len(s1)-1; // -1 for &apos;\0&apos;
  int j;

  for (j=0; 0&lt;=i ;j++) {
    s2[j] = s1[i];
    i--;
  }
  s2[j] = &apos;\0&apos;;
}
</pre>
<pre>//96</pre>
<pre>void int_to_str(int n, char s[]) {
  char s2[20];
  int i;

  for (i=0; n>0; n/=10) {
    s2[i] = &apos;0&apos; + n%10;
    i++;
  }
  s2[i]=&apos;\0&apos;;
  str_reverse(s2,s);
}</pre>
<pre>//97</pre>
<pre>void init_randoms_99(int a[], int n) {
    int i;

    for (i=0; i&lt;n; i++) {
        a[i] = rand_between(0,100); // 問題60
    }
}
</pre>
<pre>//98</pre>
<pre>void sort(int a[], int b[], int n) {
    int i;
    int j;
    int k=0;

    for (i=0; i&lt;100; i++) {
        for (j=0; j&lt;n; j++) {
            if (a[j]==i) {
                b[k] = a[j];
                k++;
            }
        }
    }
}</pre>
<pre>//99</pre>
<pre>int is_sorted(int b[], int n) {
    int i;

    for (i=0;i&lt;n-1;i++) {
        if (b[i]>b[i+1]) {
            return 0;
        }
    }
    return 1;
}</pre>
<pre>//100</pre>
<pre>int is_square(int n) {
  int i;

  for (i=1; i*i&lt;n; i++) {
    ;
  }
  return i*i==n;
}
</pre>
<pre>//101</pre>
<pre>int prime_under(int n) {
  int i;

  for (i=n;i>1;i--) { 
    if (is_prime(i)) { //p23
      return i;
    }
  }
  return 0;
}

// printf("%i\n", prime_under(power(2,16))); //p39</pre>
<pre>//102</pre>
<pre>// 2^31-1 をどう入力するかっつう、意地悪クイズ。
//printf("%i\n", prime_under(0x7fffffff)); //p101</pre>
<pre>//103</pre>
<pre>int sum_of_primes(int n) {
  int sum=2;
  int i;

  n-=1; // for prime 2
  for (i=3; n>0; i+=2) {
    if (is_prime(i)) {
      sum +=i;
      n--;
    }
  }
  return sum;
}
</pre>
<pre>//104</pre>
<pre>void prime_pythagoras(int n) {
  int primes[n];
  int i;
  int j;

  j=0;
  for (i=0; i&lt;n; i++) {
    if (is_prime(i)) {
      primes[j]=i;
      j++;
    }
  }
  primes[j]=-1;// mark
  
  for (i=0;primes[i]!=-1;i++) {
    for (j=0; j&lt;i; j++) {
      if (is_square(sq(primes[i])+sq(primes[j]))) {// p100
        printf("%i^2+%i^2 becomes square number\n",primes[i], primes[j]);
      }
    }
  }
}

// prime_pythagoras(10000); // 見つからなかった。</pre>
<pre>//105</pre>
<pre>int lcm_under_20(void) {
  int primes[] = {2,3,5,7,11,13,17,19,23};
  int i;
  int p;
  int factors[20];

  for (i=0; primes[i]&lt;=20; i++) {
    p = primes[i];
    while (p &lt;= 20) {
      factors[i] = p;
      p *= p;
    }
  }

  int ret = 1;
  for (i--; 0 &lt;= i; i--) {
    ret *= factors[i];
  }
  return ret;
}
</pre>
<pre>//106</pre>
<pre>// 途中経過を記録する配列の長さ。
// happy 数の判定に MAX 以上かかるときはお手上げ。
#define MAX 1000

// 各桁の数を2乗して総和する
int sum_of_sq_digits(int n) {
  int ret = 0;
  int d;

  for ( ;n!=0;n /= 10) {
    d = n%10;
    ret += d*d;
  }
  return ret;
}

// 配列 m[] に整数 n が含まれているか？
int find_p(int n, int m[]) {
  int i;

  for (i=0; i&lt;MAX-1; i++) {
    if (m[i]==n) {
      return 1;
    }
    if (m[i]==-1) {
      return 0;
    }
  }
  return 0;
}

// n を配列 m[] の最後に追加
void push(int n, int m[]) {
  int i;

  for (i=0; i&lt;MAX-1; i++) {
    if (m[i]==-1) {
      m[i] = n;
      m[i+1] = -1;
      return;
    }
  }
  printf(&quot;error: overflow\n&quot;);
  exit(1);
}

// 配列 mem[] の最後は -1 でマーク
int happy(int n) {
  int mem[MAX] = {-1};

  for (;;) {
    if (n==1) {
      return 1;
    }
    n = sum_of_sq_digits(n);
    if (find_p(n, mem)) {
      return 0;
    } else {
      push(n, mem);
    }
  }
}
</pre>
<pre>//107</pre>
<pre>int is_palindrome_number(int n) {
  char s1[30];
  char s2[30];

  int_to_str(n, s1); // 問題 106
  str_reverse(s1,s2); // 問題 95
  return str_eql(s1,s2); // 問題 83
}

int find_palindrome_products_max(void) {
  int x;
  int y;
  int p;
  int max=0;

  for (x=100; x&lt;=999; x++) {
    for (y=100; y&lt;=x; y++) {
      p = x * y;
      if (is_palindrome_number(p)) { // 上で定義
        if (p > max) {
          max = p;
        }
      }
    }
  }
  return max;
}
</pre>
<pre>//108</pre>
<pre>// nよりも大きい素数
int next_prime(int n) {
  n++;
  if (even(n)) { // 問題 13
    n++;
  }
  for (; ! is_prime(n); n+=2) { // 問題 23
    ;
  }
  return n;
}

// この関数は間違っている。正しい答えが得られるのはたまたま。
// 任意の整数 n に対して正しい答えを返すよう、
// 修正してください。問題 109 にするか。
int factor_integer_max(long int n) {
  int p = 2;
  int max = 1;

  for (;;) {
    if (n % p == 0) {
      max = p;
      n /= p;
      if (n == 1) {
        break;
      }
    }
    p = next_prime(p); // 上で定義
  }
  return max;
}
</pre>
<pre>//109</pre>
<pre>int factor_integer_max(long int n) {
  int p = 2;
  int max = 1;

  for (;;) {
    while  (n % p == 0) { // 同じ素因数が複数あるケースを
      max = p;            // 見逃していた。
      n /= p;
    }
    if (n == 1) {
      break;
    }
    p = next_prime(p); // 上で定義
  }
  return max;
}
</pre>
<pre>//110</pre>
<pre>sum_of_digits(n) {
  return n>0？n%10+sum_of_digits(n/10):0;
}

</pre>
<pre>//111</pre>
<pre>int times(int n, int m) {
  if (m==0) {
    return 0;
  } else {
    return n + times(n, m-1);
  }
}</pre>
<pre>//112</pre>
<pre>int add(int x, int y) {
  if (y==0) {
    return x;
  } else {
    return add(++x, --y);
  }
}
</pre>
<pre>//113</pre>
<pre>// これは簡単だった。
int doubles(int n) {
  return n&lt;&lt;1;
}</pre>
<pre>//114</pre>
<pre>// まだ考えつかない。</pre>
<pre>//115</pre>
<pre>// * 10 ができればできそう。
</pre>
      <pre>int main(void) {
    // 定義した関数の呼び出しをここに。
    return 0;
}</pre>
      <hr />
      <span>programmed by hkimura, release 0.9.6.4.
      </span>
    </div>
  </body>
</html>